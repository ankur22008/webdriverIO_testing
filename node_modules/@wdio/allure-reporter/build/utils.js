"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tellReporter = exports.ignoredHooks = exports.isEmpty = exports.getTestStatus = void 0;

require("source-map-support/register");

var _process = _interopRequireDefault(require("process"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Get allure test status by TestStat object
 * @param test {Object} - TestStat object
 * @param config {Object} - wdio config object
 * @private
 */
const getTestStatus = (test, config) => {
  if (config.framework === 'jasmine') {
    return _constants.testStatuses.FAILED;
  }

  if (test.error.name) {
    return test.error.name === 'AssertionError' ? _constants.testStatuses.FAILED : _constants.testStatuses.BROKEN;
  }

  const stackTrace = test.error.stack.trim();
  return stackTrace.startsWith('AssertionError') ? _constants.testStatuses.FAILED : _constants.testStatuses.BROKEN;
};
/**
 * Check is object is empty
 * @param object {Object}
 * @private
 */


exports.getTestStatus = getTestStatus;

const isEmpty = object => !object || Object.keys(object).length === 0;
/**
 * Filter unnecessary mocha hooks
 * @param title {String} - hook title
 * @returns {boolean}
 * @private
 */


exports.isEmpty = isEmpty;

const ignoredHooks = title => _constants.mochaIgnoredHooks.some(hook => title.includes(hook));
/**
 * Call reporter
 * @param {string} event  - event name
 * @param {Object} msg - event payload
 * @private
 */


exports.ignoredHooks = ignoredHooks;

const tellReporter = (event, msg = {}) => {
  _process.default.emit(event, msg);
};

exports.tellReporter = tellReporter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJnZXRUZXN0U3RhdHVzIiwidGVzdCIsImNvbmZpZyIsImZyYW1ld29yayIsInRlc3RTdGF0dXNlcyIsIkZBSUxFRCIsImVycm9yIiwibmFtZSIsIkJST0tFTiIsInN0YWNrVHJhY2UiLCJzdGFjayIsInRyaW0iLCJzdGFydHNXaXRoIiwiaXNFbXB0eSIsIm9iamVjdCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJpZ25vcmVkSG9va3MiLCJ0aXRsZSIsIm1vY2hhSWdub3JlZEhvb2tzIiwic29tZSIsImhvb2siLCJpbmNsdWRlcyIsInRlbGxSZXBvcnRlciIsImV2ZW50IiwibXNnIiwicHJvY2VzcyIsImVtaXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQU1PLE1BQU1BLGFBQWEsR0FBRyxDQUFDQyxJQUFELEVBQU9DLE1BQVAsS0FBa0I7QUFDM0MsTUFBSUEsTUFBTSxDQUFDQyxTQUFQLEtBQXFCLFNBQXpCLEVBQW9DO0FBQ2hDLFdBQU9DLHdCQUFhQyxNQUFwQjtBQUNIOztBQUVELE1BQUlKLElBQUksQ0FBQ0ssS0FBTCxDQUFXQyxJQUFmLEVBQXFCO0FBQ2pCLFdBQU9OLElBQUksQ0FBQ0ssS0FBTCxDQUFXQyxJQUFYLEtBQW9CLGdCQUFwQixHQUF1Q0gsd0JBQWFDLE1BQXBELEdBQTZERCx3QkFBYUksTUFBakY7QUFDSDs7QUFFRCxRQUFNQyxVQUFVLEdBQUdSLElBQUksQ0FBQ0ssS0FBTCxDQUFXSSxLQUFYLENBQWlCQyxJQUFqQixFQUFuQjtBQUNBLFNBQU9GLFVBQVUsQ0FBQ0csVUFBWCxDQUFzQixnQkFBdEIsSUFBMENSLHdCQUFhQyxNQUF2RCxHQUFnRUQsd0JBQWFJLE1BQXBGO0FBRUgsQ0FaTTtBQWNQOzs7Ozs7Ozs7QUFLTyxNQUFNSyxPQUFPLEdBQUlDLE1BQUQsSUFBWSxDQUFDQSxNQUFELElBQVdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZRixNQUFaLEVBQW9CRyxNQUFwQixLQUErQixDQUF0RTtBQUVQOzs7Ozs7Ozs7O0FBTU8sTUFBTUMsWUFBWSxHQUFHQyxLQUFLLElBQUlDLDZCQUFrQkMsSUFBbEIsQ0FBdUJDLElBQUksSUFBSUgsS0FBSyxDQUFDSSxRQUFOLENBQWVELElBQWYsQ0FBL0IsQ0FBOUI7QUFFUDs7Ozs7Ozs7OztBQU1PLE1BQU1FLFlBQVksR0FBRyxDQUFDQyxLQUFELEVBQVFDLEdBQUcsR0FBRyxFQUFkLEtBQXFCO0FBQzdDQyxtQkFBUUMsSUFBUixDQUFhSCxLQUFiLEVBQW9CQyxHQUFwQjtBQUNILENBRk0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJ1xuaW1wb3J0IHt0ZXN0U3RhdHVzZXMsIG1vY2hhSWdub3JlZEhvb2tzfSBmcm9tICcuL2NvbnN0YW50cydcbi8qKlxuICogR2V0IGFsbHVyZSB0ZXN0IHN0YXR1cyBieSBUZXN0U3RhdCBvYmplY3RcbiAqIEBwYXJhbSB0ZXN0IHtPYmplY3R9IC0gVGVzdFN0YXQgb2JqZWN0XG4gKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IC0gd2RpbyBjb25maWcgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0VGVzdFN0YXR1cyA9ICh0ZXN0LCBjb25maWcpID0+IHtcbiAgICBpZiAoY29uZmlnLmZyYW1ld29yayA9PT0gJ2phc21pbmUnKSB7XG4gICAgICAgIHJldHVybiB0ZXN0U3RhdHVzZXMuRkFJTEVEXG4gICAgfVxuXG4gICAgaWYgKHRlc3QuZXJyb3IubmFtZSkge1xuICAgICAgICByZXR1cm4gdGVzdC5lcnJvci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InID8gdGVzdFN0YXR1c2VzLkZBSUxFRCA6IHRlc3RTdGF0dXNlcy5CUk9LRU5cbiAgICB9XG5cbiAgICBjb25zdCBzdGFja1RyYWNlID0gdGVzdC5lcnJvci5zdGFjay50cmltKClcbiAgICByZXR1cm4gc3RhY2tUcmFjZS5zdGFydHNXaXRoKCdBc3NlcnRpb25FcnJvcicpID8gdGVzdFN0YXR1c2VzLkZBSUxFRCA6IHRlc3RTdGF0dXNlcy5CUk9LRU5cblxufVxuXG4vKipcbiAqIENoZWNrIGlzIG9iamVjdCBpcyBlbXB0eVxuICogQHBhcmFtIG9iamVjdCB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSAob2JqZWN0KSA9PiAhb2JqZWN0IHx8IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwXG5cbi8qKlxuICogRmlsdGVyIHVubmVjZXNzYXJ5IG1vY2hhIGhvb2tzXG4gKiBAcGFyYW0gdGl0bGUge1N0cmluZ30gLSBob29rIHRpdGxlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBpZ25vcmVkSG9va3MgPSB0aXRsZSA9PiBtb2NoYUlnbm9yZWRIb29rcy5zb21lKGhvb2sgPT4gdGl0bGUuaW5jbHVkZXMoaG9vaykpXG5cbi8qKlxuICogQ2FsbCByZXBvcnRlclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAtIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgLSBldmVudCBwYXlsb2FkXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgdGVsbFJlcG9ydGVyID0gKGV2ZW50LCBtc2cgPSB7fSkgPT4ge1xuICAgIHByb2Nlc3MuZW1pdChldmVudCwgbXNnKVxufVxuIl19