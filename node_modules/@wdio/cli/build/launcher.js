"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _asyncExitHook = _interopRequireDefault(require("async-exit-hook"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _config = require("@wdio/config");

var _interface = _interopRequireDefault(require("./interface"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('wdio-cli:Launcher');

class Launcher {
  constructor(configFile, argv) {
    this.argv = argv;
    this.configFile = configFile;
    this.configParser = new _config.ConfigParser();
    this.configParser.addConfigFile(configFile);
    this.configParser.merge(argv);
    const config = this.configParser.getConfig();
    const capabilities = this.configParser.getCapabilities();
    const specs = this.configParser.getSpecs();

    if (config.logDir) {
      process.env.WDIO_LOG_PATH = _path.default.join(config.logDir, 'wdio.log');
    }

    const totalWorkerCnt = Array.isArray(capabilities) ? capabilities.map(c => this.configParser.getSpecs(c.specs, c.exclude).length).reduce((a, b) => a + b, 0) : 1;
    this.interface = new _interface.default(config, specs, totalWorkerCnt);
    config.runnerEnv.FORCE_COLOR = Number(this.interface.hasAnsiSupport);
    const Runner = (0, _config.initialisePlugin)(config.runner, 'runner');
    this.runner = new Runner(configFile, config);
    this.isMultiremote = !Array.isArray(capabilities);
    this.exitCode = 0;
    this.hasTriggeredExitRoutine = false;
    this.hasStartedAnyProcess = false;
    this.schedule = [];
    this.rid = [];
    this.runnerStarted = 0;
    this.runnerFailed = 0;
  }
  /**
   * run sequence
   * @return  {Promise} that only gets resolves with either an exitCode or an error
   */


  async run() {
    let config = this.configParser.getConfig();
    let caps = this.configParser.getCapabilities();
    const launcher = (0, _utils.getLauncher)(config);
    /**
     * run pre test tasks for runner plugins
     * (e.g. deploy Lambda functio to AWS)
     */

    await this.runner.initialise();
    /**
     * run onPrepare hook
     */

    await config.onPrepare(config, caps);
    log.info('Run onPrepare hook');
    await (0, _utils.runServiceHook)(launcher, 'onPrepare', config, caps);
    /**
     * catches ctrl+c event
     */

    (0, _asyncExitHook.default)(this.exitHandler.bind(this));
    const exitCode = await this.runMode(config, caps);
    /**
     * run onComplete hook
     */

    log.info('Run onComplete hook');
    await (0, _utils.runServiceHook)(launcher, 'onComplete', exitCode, config, caps);
    await config.onComplete(exitCode, config, caps, this.interface.result);
    this.interface.updateView();
    return exitCode;
  }
  /**
   * run without triggering onPrepare/onComplete hooks
   */


  runMode(config, caps) {
    /**
     * if it is an object run multiremote test
     */
    if (this.isMultiremote) {
      return new Promise(resolve => {
        this.resolve = resolve;
        this.startInstance(this.configParser.getSpecs(), caps, 0);
      });
    }
    /**
     * schedule test runs
     */


    let cid = 0;

    for (let capabilities of caps) {
      this.schedule.push({
        cid: cid++,
        caps: capabilities,
        specs: this.configParser.getSpecs(capabilities.specs, capabilities.exclude),
        availableInstances: capabilities.maxInstances || config.maxInstancesPerCapability,
        runningInstances: 0,
        seleniumServer: {
          hostname: config.hostname,
          port: config.port,
          protocol: config.protocol
        }
      });
    }

    return new Promise(resolve => {
      this.resolve = resolve;
      /**
       * fail if no specs were found or specified
       */

      if (Object.values(this.schedule).reduce((specCnt, schedule) => specCnt + schedule.specs.length, 0) === 0) {
        log.error('No specs found to run, exiting with failure');
        this.interface.updateView();
        return resolve(1);
      }
      /**
       * return immediately if no spec was run
       */


      if (this.runSpecs()) {
        resolve(0);
      }
    });
  }
  /**
   * run multiple single remote tests
   * @return {Boolean} true if all specs have been run and all instances have finished
   */


  runSpecs() {
    let config = this.configParser.getConfig();
    /**
     * stop spawning new processes when CTRL+C was triggered
     */

    if (this.hasTriggeredExitRoutine) {
      return true;
    }

    while (this.getNumberOfRunningInstances() < config.maxInstances) {
      let schedulableCaps = this.schedule
      /**
       * bail if number of errors exceeds allowed
       */
      .filter(() => {
        const filter = typeof config.bail !== 'number' || config.bail < 1 || config.bail > this.runnerFailed;
        /**
         * clear number of specs when filter is false
         */

        if (!filter) {
          this.schedule.forEach(t => {
            t.specs = [];
          });
        }

        return filter;
      })
      /**
       * make sure complete number of running instances is not higher than general maxInstances number
       */
      .filter(() => this.getNumberOfRunningInstances() < config.maxInstances)
      /**
       * make sure the capability has available capacities
       */
      .filter(a => a.availableInstances > 0)
      /**
       * make sure capability has still caps to run
       */
      .filter(a => a.specs.length > 0)
      /**
       * make sure we are running caps with less running instances first
       */
      .sort((a, b) => a.runningInstances > b.runningInstances);
      /**
       * continue if no capability were schedulable
       */

      if (schedulableCaps.length === 0) {
        break;
      }

      this.startInstance([schedulableCaps[0].specs.shift()], schedulableCaps[0].caps, schedulableCaps[0].cid, schedulableCaps[0].seleniumServer);
      schedulableCaps[0].availableInstances--;
      schedulableCaps[0].runningInstances++;
    }

    return this.getNumberOfRunningInstances() === 0 && this.getNumberOfSpecsLeft() === 0;
  }
  /**
   * gets number of all running instances
   * @return {number} number of running instances
   */


  getNumberOfRunningInstances() {
    return this.schedule.map(a => a.runningInstances).reduce((a, b) => a + b);
  }
  /**
   * get number of total specs left to complete whole suites
   * @return {number} specs left to complete suite
   */


  getNumberOfSpecsLeft() {
    return this.schedule.map(a => a.specs.length).reduce((a, b) => a + b);
  }
  /**
   * Start instance in a child process.
   * @param  {Array} specs  Specs to run
   * @param  {Number} cid  Capabilities ID
   */


  startInstance(specs, caps, cid, server) {
    var _context;

    let config = this.configParser.getConfig();
    cid = this.getRunnerId(cid);
    let processNumber = this.runnerStarted + 1; // process.debugPort defaults to 5858 and is set even when process
    // is not being debugged.

    let debugArgs = [];
    let debugType;
    let debugHost = '';
    let debugPort = process.debugPort;

    for (let i in process.execArgv) {
      const debugArgs = process.execArgv[i].match('--(debug|inspect)(?:-brk)?(?:=(.*):)?');

      if (debugArgs) {
        let [, type, host] = debugArgs;

        if (type) {
          debugType = type;
        }

        if (host) {
          debugHost = `${host}:`;
        }
      }
    }

    if (debugType) {
      debugArgs.push(`--${debugType}=${debugHost}${debugPort + processNumber}`);
    } // if you would like to add --debug-brk, use a different port, etc...


    let capExecArgs = [...(config.execArgv || []), ...(caps.execArgv || [])]; // The default value for child.fork execArgs is process.execArgs,
    // so continue to use this unless another value is specified in config.

    let defaultArgs = capExecArgs.length ? process.execArgv : []; // If an arg appears multiple times the last occurrence is used

    let execArgv = [...defaultArgs, ...debugArgs, ...capExecArgs]; // prefer launcher settings in capabilities over general launcher

    const worker = this.runner.run({
      cid,
      command: 'run',
      configFile: this.configFile,
      argv: this.argv,
      caps,
      specs,
      server,
      execArgv
    });
    worker.on('message', (_context = this.interface).onMessage.bind(_context));
    worker.on('error', (_context = this.interface).onMessage.bind(_context));
    worker.on('exit', this.endHandler.bind(this));
    this.interface.emit('job:start', {
      cid,
      caps,
      specs
    });
    this.runnerStarted++;
  }
  /**
   * generates a runner id
   * @param  {Number} cid capability id (unique identifier for a capability)
   * @return {String}     runner id (combination of cid and test id e.g. 0a, 0b, 1a, 1b ...)
   */


  getRunnerId(cid) {
    if (!this.rid[cid]) {
      this.rid[cid] = 0;
    }

    return `${cid}-${this.rid[cid]++}`;
  }
  /**
   * Close test runner process once all child processes have exited
   * @param  {Number} cid       Capabilities ID
   * @param  {Number} exitCode  exit code of child process
   */


  endHandler({
    cid,
    exitCode
  }) {
    const passed = exitCode === 0;
    this.exitCode = this.exitCode || exitCode;
    this.runnerFailed += !passed ? 1 : 0;
    this.interface.emit('job:end', {
      cid,
      passed
    }); // Update schedule now this process has ended

    if (!this.isMultiremote) {
      // get cid (capability id) from rid (runner id)
      cid = parseInt(cid, 10);
      this.schedule[cid].availableInstances++;
      this.schedule[cid].runningInstances--;
    }

    if (!this.isMultiremote && !this.runSpecs()) {
      return;
    }

    if (passed) {
      return process.nextTick(() => {
        this.interface.updateView();
        this.interface.reset();
        setTimeout(() => this.resolve(this.exitCode), 100);
      });
    }
    /**
     * finish with exit code 1
     */


    return process.nextTick(() => {
      this.interface.updateView();
      this.interface.reset();
      setTimeout(() => this.resolve(1), 100);
    });
  }
  /**
   * Make sure all started selenium sessions get closed properly and prevent
   * having dead driver processes. To do so let the runner end its Selenium
   * session first before killing
   */


  exitHandler(callback) {
    if (!callback) {
      return;
    }

    this.hasTriggeredExitRoutine = true;
    this.interface.sigintTrigger();
    return this.runner.shutdown().then(callback);
  }

}

var _default = Launcher;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXVuY2hlci5qcyJdLCJuYW1lcyI6WyJsb2ciLCJMYXVuY2hlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmlsZSIsImFyZ3YiLCJjb25maWdQYXJzZXIiLCJDb25maWdQYXJzZXIiLCJhZGRDb25maWdGaWxlIiwibWVyZ2UiLCJjb25maWciLCJnZXRDb25maWciLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJzcGVjcyIsImdldFNwZWNzIiwibG9nRGlyIiwicHJvY2VzcyIsImVudiIsIldESU9fTE9HX1BBVEgiLCJwYXRoIiwiam9pbiIsInRvdGFsV29ya2VyQ250IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiYyIsImV4Y2x1ZGUiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiYiIsImludGVyZmFjZSIsIkNMSW50ZXJmYWNlIiwicnVubmVyRW52IiwiRk9SQ0VfQ09MT1IiLCJOdW1iZXIiLCJoYXNBbnNpU3VwcG9ydCIsIlJ1bm5lciIsInJ1bm5lciIsImlzTXVsdGlyZW1vdGUiLCJleGl0Q29kZSIsImhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lIiwiaGFzU3RhcnRlZEFueVByb2Nlc3MiLCJzY2hlZHVsZSIsInJpZCIsInJ1bm5lclN0YXJ0ZWQiLCJydW5uZXJGYWlsZWQiLCJydW4iLCJjYXBzIiwibGF1bmNoZXIiLCJpbml0aWFsaXNlIiwib25QcmVwYXJlIiwiaW5mbyIsImV4aXRIYW5kbGVyIiwicnVuTW9kZSIsIm9uQ29tcGxldGUiLCJyZXN1bHQiLCJ1cGRhdGVWaWV3IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGFydEluc3RhbmNlIiwiY2lkIiwicHVzaCIsImF2YWlsYWJsZUluc3RhbmNlcyIsIm1heEluc3RhbmNlcyIsIm1heEluc3RhbmNlc1BlckNhcGFiaWxpdHkiLCJydW5uaW5nSW5zdGFuY2VzIiwic2VsZW5pdW1TZXJ2ZXIiLCJob3N0bmFtZSIsInBvcnQiLCJwcm90b2NvbCIsIk9iamVjdCIsInZhbHVlcyIsInNwZWNDbnQiLCJlcnJvciIsInJ1blNwZWNzIiwiZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzIiwic2NoZWR1bGFibGVDYXBzIiwiZmlsdGVyIiwiYmFpbCIsImZvckVhY2giLCJ0Iiwic29ydCIsInNoaWZ0IiwiZ2V0TnVtYmVyT2ZTcGVjc0xlZnQiLCJzZXJ2ZXIiLCJnZXRSdW5uZXJJZCIsInByb2Nlc3NOdW1iZXIiLCJkZWJ1Z0FyZ3MiLCJkZWJ1Z1R5cGUiLCJkZWJ1Z0hvc3QiLCJkZWJ1Z1BvcnQiLCJpIiwiZXhlY0FyZ3YiLCJtYXRjaCIsInR5cGUiLCJob3N0IiwiY2FwRXhlY0FyZ3MiLCJkZWZhdWx0QXJncyIsIndvcmtlciIsImNvbW1hbmQiLCJvbiIsIm9uTWVzc2FnZSIsImVuZEhhbmRsZXIiLCJlbWl0IiwicGFzc2VkIiwicGFyc2VJbnQiLCJuZXh0VGljayIsInJlc2V0Iiwic2V0VGltZW91dCIsImNhbGxiYWNrIiwic2lnaW50VHJpZ2dlciIsInNodXRkb3duIiwidGhlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxHQUFHLEdBQUcscUJBQU8sbUJBQVAsQ0FBWjs7QUFFQSxNQUFNQyxRQUFOLENBQWU7QUFDWEMsRUFBQUEsV0FBVyxDQUFFQyxVQUFGLEVBQWNDLElBQWQsRUFBb0I7QUFDM0IsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0QsVUFBTCxHQUFrQkEsVUFBbEI7QUFFQSxTQUFLRSxZQUFMLEdBQW9CLElBQUlDLG9CQUFKLEVBQXBCO0FBQ0EsU0FBS0QsWUFBTCxDQUFrQkUsYUFBbEIsQ0FBZ0NKLFVBQWhDO0FBQ0EsU0FBS0UsWUFBTCxDQUFrQkcsS0FBbEIsQ0FBd0JKLElBQXhCO0FBRUEsVUFBTUssTUFBTSxHQUFHLEtBQUtKLFlBQUwsQ0FBa0JLLFNBQWxCLEVBQWY7QUFDQSxVQUFNQyxZQUFZLEdBQUcsS0FBS04sWUFBTCxDQUFrQk8sZUFBbEIsRUFBckI7QUFD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QUtsQixRQUFMLENBQWNrQixHQUFkLEVBQW1CRSxrQkFBbkI7QUFDQSxXQUFLcEIsUUFBTCxDQUFja0IsR0FBZCxFQUFtQkssZ0JBQW5CO0FBQ0g7O0FBRUQsUUFBSSxDQUFDLEtBQUszQixhQUFOLElBQXVCLENBQUMsS0FBS29DLFFBQUwsRUFBNUIsRUFBNkM7QUFDekM7QUFDSDs7QUFFRCxRQUFJOEIsTUFBSixFQUFZO0FBQ1IsYUFBT3pGLE9BQU8sQ0FBQzJGLFFBQVIsQ0FBaUIsTUFBTTtBQUMxQixhQUFLNUUsU0FBTCxDQUFlMEIsVUFBZjtBQUNBLGFBQUsxQixTQUFMLENBQWU2RSxLQUFmO0FBQ0FDLFFBQUFBLFVBQVUsQ0FBQyxNQUFNLEtBQUtsRCxPQUFMLENBQWEsS0FBS25CLFFBQWxCLENBQVAsRUFBb0MsR0FBcEMsQ0FBVjtBQUNILE9BSk0sQ0FBUDtBQUtIO0FBRUQ7Ozs7O0FBR0EsV0FBT3hCLE9BQU8sQ0FBQzJGLFFBQVIsQ0FBaUIsTUFBTTtBQUMxQixXQUFLNUUsU0FBTCxDQUFlMEIsVUFBZjtBQUNBLFdBQUsxQixTQUFMLENBQWU2RSxLQUFmO0FBQ0FDLE1BQUFBLFVBQVUsQ0FBQyxNQUFNLEtBQUtsRCxPQUFMLENBQWEsQ0FBYixDQUFQLEVBQXdCLEdBQXhCLENBQVY7QUFDSCxLQUpNLENBQVA7QUFLSDtBQUVEOzs7Ozs7O0FBS0FOLEVBQUFBLFdBQVcsQ0FBRXlELFFBQUYsRUFBWTtBQUNuQixRQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNYO0FBQ0g7O0FBRUQsU0FBS3JFLHVCQUFMLEdBQStCLElBQS9CO0FBQ0EsU0FBS1YsU0FBTCxDQUFlZ0YsYUFBZjtBQUNBLFdBQU8sS0FBS3pFLE1BQUwsQ0FBWTBFLFFBQVosR0FBdUJDLElBQXZCLENBQTRCSCxRQUE1QixDQUFQO0FBQ0g7O0FBMVZVOztlQTZWQTdHLFEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IGV4aXRIb29rIGZyb20gJ2FzeW5jLWV4aXQtaG9vaydcblxuaW1wb3J0IGxvZ2dlciBmcm9tICdAd2Rpby9sb2dnZXInXG5pbXBvcnQgeyBDb25maWdQYXJzZXIsIGluaXRpYWxpc2VQbHVnaW4gfSBmcm9tICdAd2Rpby9jb25maWcnXG5cbmltcG9ydCBDTEludGVyZmFjZSBmcm9tICcuL2ludGVyZmFjZSdcbmltcG9ydCB7IGdldExhdW5jaGVyLCBydW5TZXJ2aWNlSG9vayB9IGZyb20gJy4vdXRpbHMnXG5cbmNvbnN0IGxvZyA9IGxvZ2dlcignd2Rpby1jbGk6TGF1bmNoZXInKVxuXG5jbGFzcyBMYXVuY2hlciB7XG4gICAgY29uc3RydWN0b3IgKGNvbmZpZ0ZpbGUsIGFyZ3YpIHtcbiAgICAgICAgdGhpcy5hcmd2ID0gYXJndlxuICAgICAgICB0aGlzLmNvbmZpZ0ZpbGUgPSBjb25maWdGaWxlXG5cbiAgICAgICAgdGhpcy5jb25maWdQYXJzZXIgPSBuZXcgQ29uZmlnUGFyc2VyKClcbiAgICAgICAgdGhpcy5jb25maWdQYXJzZXIuYWRkQ29uZmlnRmlsZShjb25maWdGaWxlKVxuICAgICAgICB0aGlzLmNvbmZpZ1BhcnNlci5tZXJnZShhcmd2KVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG4gICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENhcGFiaWxpdGllcygpXG4gICAgICAgIGNvbnN0IHNwZWNzID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0U3BlY3MoKVxuXG4gICAgICAgIGlmIChjb25maWcubG9nRGlyKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5XRElPX0xPR19QQVRIID0gcGF0aC5qb2luKGNvbmZpZy5sb2dEaXIsICd3ZGlvLmxvZycpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbFdvcmtlckNudCA9IEFycmF5LmlzQXJyYXkoY2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgPyBjYXBhYmlsaXRpZXNcbiAgICAgICAgICAgICAgICAubWFwKChjKSA9PiB0aGlzLmNvbmZpZ1BhcnNlci5nZXRTcGVjcyhjLnNwZWNzLCBjLmV4Y2x1ZGUpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICAgICAgICAgIDogMVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlID0gbmV3IENMSW50ZXJmYWNlKGNvbmZpZywgc3BlY3MsIHRvdGFsV29ya2VyQ250KVxuICAgICAgICBjb25maWcucnVubmVyRW52LkZPUkNFX0NPTE9SID0gTnVtYmVyKHRoaXMuaW50ZXJmYWNlLmhhc0Fuc2lTdXBwb3J0KVxuXG4gICAgICAgIGNvbnN0IFJ1bm5lciA9IGluaXRpYWxpc2VQbHVnaW4oY29uZmlnLnJ1bm5lciwgJ3J1bm5lcicpXG4gICAgICAgIHRoaXMucnVubmVyID0gbmV3IFJ1bm5lcihjb25maWdGaWxlLCBjb25maWcpXG5cbiAgICAgICAgdGhpcy5pc011bHRpcmVtb3RlID0gIUFycmF5LmlzQXJyYXkoY2FwYWJpbGl0aWVzKVxuICAgICAgICB0aGlzLmV4aXRDb2RlID0gMFxuICAgICAgICB0aGlzLmhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkQW55UHJvY2VzcyA9IGZhbHNlXG4gICAgICAgIHRoaXMuc2NoZWR1bGUgPSBbXVxuICAgICAgICB0aGlzLnJpZCA9IFtdXG4gICAgICAgIHRoaXMucnVubmVyU3RhcnRlZCA9IDBcbiAgICAgICAgdGhpcy5ydW5uZXJGYWlsZWQgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIHNlcXVlbmNlXG4gICAgICogQHJldHVybiAge1Byb21pc2V9IHRoYXQgb25seSBnZXRzIHJlc29sdmVzIHdpdGggZWl0aGVyIGFuIGV4aXRDb2RlIG9yIGFuIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgcnVuICgpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG4gICAgICAgIGxldCBjYXBzID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q2FwYWJpbGl0aWVzKClcbiAgICAgICAgY29uc3QgbGF1bmNoZXIgPSBnZXRMYXVuY2hlcihjb25maWcpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJ1biBwcmUgdGVzdCB0YXNrcyBmb3IgcnVubmVyIHBsdWdpbnNcbiAgICAgICAgICogKGUuZy4gZGVwbG95IExhbWJkYSBmdW5jdGlvIHRvIEFXUylcbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IHRoaXMucnVubmVyLmluaXRpYWxpc2UoKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBydW4gb25QcmVwYXJlIGhvb2tcbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IGNvbmZpZy5vblByZXBhcmUoY29uZmlnLCBjYXBzKVxuICAgICAgICBsb2cuaW5mbygnUnVuIG9uUHJlcGFyZSBob29rJylcbiAgICAgICAgYXdhaXQgcnVuU2VydmljZUhvb2sobGF1bmNoZXIsICdvblByZXBhcmUnLCBjb25maWcsIGNhcHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhdGNoZXMgY3RybCtjIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBleGl0SG9vayg6OnRoaXMuZXhpdEhhbmRsZXIpXG5cbiAgICAgICAgY29uc3QgZXhpdENvZGUgPSBhd2FpdCB0aGlzLnJ1bk1vZGUoY29uZmlnLCBjYXBzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBydW4gb25Db21wbGV0ZSBob29rXG4gICAgICAgICAqL1xuICAgICAgICBsb2cuaW5mbygnUnVuIG9uQ29tcGxldGUgaG9vaycpXG4gICAgICAgIGF3YWl0IHJ1blNlcnZpY2VIb29rKGxhdW5jaGVyLCAnb25Db21wbGV0ZScsIGV4aXRDb2RlLCBjb25maWcsIGNhcHMpXG4gICAgICAgIGF3YWl0IGNvbmZpZy5vbkNvbXBsZXRlKGV4aXRDb2RlLCBjb25maWcsIGNhcHMsIHRoaXMuaW50ZXJmYWNlLnJlc3VsdClcblxuICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgcmV0dXJuIGV4aXRDb2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIHdpdGhvdXQgdHJpZ2dlcmluZyBvblByZXBhcmUvb25Db21wbGV0ZSBob29rc1xuICAgICAqL1xuICAgIHJ1bk1vZGUgKGNvbmZpZywgY2Fwcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYgaXQgaXMgYW4gb2JqZWN0IHJ1biBtdWx0aXJlbW90ZSB0ZXN0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5pc011bHRpcmVtb3RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEluc3RhbmNlKHRoaXMuY29uZmlnUGFyc2VyLmdldFNwZWNzKCksIGNhcHMsIDApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNjaGVkdWxlIHRlc3QgcnVuc1xuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGNpZCA9IDBcbiAgICAgICAgZm9yIChsZXQgY2FwYWJpbGl0aWVzIG9mIGNhcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUucHVzaCh7XG4gICAgICAgICAgICAgICAgY2lkOiBjaWQrKyxcbiAgICAgICAgICAgICAgICBjYXBzOiBjYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgc3BlY3M6IHRoaXMuY29uZmlnUGFyc2VyLmdldFNwZWNzKGNhcGFiaWxpdGllcy5zcGVjcywgY2FwYWJpbGl0aWVzLmV4Y2x1ZGUpLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUluc3RhbmNlczogY2FwYWJpbGl0aWVzLm1heEluc3RhbmNlcyB8fCBjb25maWcubWF4SW5zdGFuY2VzUGVyQ2FwYWJpbGl0eSxcbiAgICAgICAgICAgICAgICBydW5uaW5nSW5zdGFuY2VzOiAwLFxuICAgICAgICAgICAgICAgIHNlbGVuaXVtU2VydmVyOiB7IGhvc3RuYW1lOiBjb25maWcuaG9zdG5hbWUsIHBvcnQ6IGNvbmZpZy5wb3J0LCBwcm90b2NvbDogY29uZmlnLnByb3RvY29sIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBmYWlsIGlmIG5vIHNwZWNzIHdlcmUgZm91bmQgb3Igc3BlY2lmaWVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKHRoaXMuc2NoZWR1bGUpLnJlZHVjZSgoc3BlY0NudCwgc2NoZWR1bGUpID0+IHNwZWNDbnQgKyBzY2hlZHVsZS5zcGVjcy5sZW5ndGgsIDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdObyBzcGVjcyBmb3VuZCB0byBydW4sIGV4aXRpbmcgd2l0aCBmYWlsdXJlJylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybiBpbW1lZGlhdGVseSBpZiBubyBzcGVjIHdhcyBydW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuU3BlY3MoKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gbXVsdGlwbGUgc2luZ2xlIHJlbW90ZSB0ZXN0c1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYWxsIHNwZWNzIGhhdmUgYmVlbiBydW4gYW5kIGFsbCBpbnN0YW5jZXMgaGF2ZSBmaW5pc2hlZFxuICAgICAqL1xuICAgIHJ1blNwZWNzICgpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3Agc3Bhd25pbmcgbmV3IHByb2Nlc3NlcyB3aGVuIENUUkwrQyB3YXMgdHJpZ2dlcmVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5oYXNUcmlnZ2VyZWRFeGl0Um91dGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpIDwgY29uZmlnLm1heEluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IHNjaGVkdWxhYmxlQ2FwcyA9IHRoaXMuc2NoZWR1bGVcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBiYWlsIGlmIG51bWJlciBvZiBlcnJvcnMgZXhjZWVkcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHR5cGVvZiBjb25maWcuYmFpbCAhPT0gJ251bWJlcicgfHwgY29uZmlnLmJhaWwgPCAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5iYWlsID4gdGhpcy5ydW5uZXJGYWlsZWRcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogY2xlYXIgbnVtYmVyIG9mIHNwZWNzIHdoZW4gZmlsdGVyIGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZS5mb3JFYWNoKCh0KSA9PiB7IHQuc3BlY3MgPSBbXSB9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogbWFrZSBzdXJlIGNvbXBsZXRlIG51bWJlciBvZiBydW5uaW5nIGluc3RhbmNlcyBpcyBub3QgaGlnaGVyIHRoYW4gZ2VuZXJhbCBtYXhJbnN0YW5jZXMgbnVtYmVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoKSA9PiB0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpIDwgY29uZmlnLm1heEluc3RhbmNlcylcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBtYWtlIHN1cmUgdGhlIGNhcGFiaWxpdHkgaGFzIGF2YWlsYWJsZSBjYXBhY2l0aWVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYS5hdmFpbGFibGVJbnN0YW5jZXMgPiAwKVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG1ha2Ugc3VyZSBjYXBhYmlsaXR5IGhhcyBzdGlsbCBjYXBzIHRvIHJ1blxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGEpID0+IGEuc3BlY3MubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBtYWtlIHN1cmUgd2UgYXJlIHJ1bm5pbmcgY2FwcyB3aXRoIGxlc3MgcnVubmluZyBpbnN0YW5jZXMgZmlyc3RcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5ydW5uaW5nSW5zdGFuY2VzID4gYi5ydW5uaW5nSW5zdGFuY2VzKVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGNvbnRpbnVlIGlmIG5vIGNhcGFiaWxpdHkgd2VyZSBzY2hlZHVsYWJsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGFibGVDYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBbc2NoZWR1bGFibGVDYXBzWzBdLnNwZWNzLnNoaWZ0KCldLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5jYXBzLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5jaWQsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGFibGVDYXBzWzBdLnNlbGVuaXVtU2VydmVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBzY2hlZHVsYWJsZUNhcHNbMF0uYXZhaWxhYmxlSW5zdGFuY2VzLS1cbiAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5ydW5uaW5nSW5zdGFuY2VzKytcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpID09PSAwICYmIHRoaXMuZ2V0TnVtYmVyT2ZTcGVjc0xlZnQoKSA9PT0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldHMgbnVtYmVyIG9mIGFsbCBydW5uaW5nIGluc3RhbmNlc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJ1bm5pbmcgaW5zdGFuY2VzXG4gICAgICovXG4gICAgZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUubWFwKChhKSA9PiBhLnJ1bm5pbmdJbnN0YW5jZXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiB0b3RhbCBzcGVjcyBsZWZ0IHRvIGNvbXBsZXRlIHdob2xlIHN1aXRlc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gc3BlY3MgbGVmdCB0byBjb21wbGV0ZSBzdWl0ZVxuICAgICAqL1xuICAgIGdldE51bWJlck9mU3BlY3NMZWZ0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUubWFwKChhKSA9PiBhLnNwZWNzLmxlbmd0aCkucmVkdWNlKChhLCBiKSA9PiBhICsgYilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBpbnN0YW5jZSBpbiBhIGNoaWxkIHByb2Nlc3MuXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHNwZWNzICBTcGVjcyB0byBydW5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNpZCAgQ2FwYWJpbGl0aWVzIElEXG4gICAgICovXG4gICAgc3RhcnRJbnN0YW5jZSAoc3BlY3MsIGNhcHMsIGNpZCwgc2VydmVyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRDb25maWcoKVxuICAgICAgICBjaWQgPSB0aGlzLmdldFJ1bm5lcklkKGNpZClcbiAgICAgICAgbGV0IHByb2Nlc3NOdW1iZXIgPSB0aGlzLnJ1bm5lclN0YXJ0ZWQgKyAxXG5cbiAgICAgICAgLy8gcHJvY2Vzcy5kZWJ1Z1BvcnQgZGVmYXVsdHMgdG8gNTg1OCBhbmQgaXMgc2V0IGV2ZW4gd2hlbiBwcm9jZXNzXG4gICAgICAgIC8vIGlzIG5vdCBiZWluZyBkZWJ1Z2dlZC5cbiAgICAgICAgbGV0IGRlYnVnQXJncyA9IFtdXG4gICAgICAgIGxldCBkZWJ1Z1R5cGVcbiAgICAgICAgbGV0IGRlYnVnSG9zdCA9ICcnXG4gICAgICAgIGxldCBkZWJ1Z1BvcnQgPSBwcm9jZXNzLmRlYnVnUG9ydFxuICAgICAgICBmb3IgKGxldCBpIGluIHByb2Nlc3MuZXhlY0FyZ3YpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnQXJncyA9IHByb2Nlc3MuZXhlY0FyZ3ZbaV0ubWF0Y2goJy0tKGRlYnVnfGluc3BlY3QpKD86LWJyayk/KD86PSguKik6KT8nKVxuICAgICAgICAgICAgaWYgKGRlYnVnQXJncykge1xuICAgICAgICAgICAgICAgIGxldCBbLCB0eXBlLCBob3N0XSA9IGRlYnVnQXJnc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVHlwZSA9IHR5cGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdIb3N0ID0gYCR7aG9zdH06YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1Z1R5cGUpIHtcbiAgICAgICAgICAgIGRlYnVnQXJncy5wdXNoKGAtLSR7ZGVidWdUeXBlfT0ke2RlYnVnSG9zdH0keyhkZWJ1Z1BvcnQgKyBwcm9jZXNzTnVtYmVyKX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgeW91IHdvdWxkIGxpa2UgdG8gYWRkIC0tZGVidWctYnJrLCB1c2UgYSBkaWZmZXJlbnQgcG9ydCwgZXRjLi4uXG4gICAgICAgIGxldCBjYXBFeGVjQXJncyA9IFtcbiAgICAgICAgICAgIC4uLihjb25maWcuZXhlY0FyZ3YgfHwgW10pLFxuICAgICAgICAgICAgLi4uKGNhcHMuZXhlY0FyZ3YgfHwgW10pXG4gICAgICAgIF1cblxuICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgY2hpbGQuZm9yayBleGVjQXJncyBpcyBwcm9jZXNzLmV4ZWNBcmdzLFxuICAgICAgICAvLyBzbyBjb250aW51ZSB0byB1c2UgdGhpcyB1bmxlc3MgYW5vdGhlciB2YWx1ZSBpcyBzcGVjaWZpZWQgaW4gY29uZmlnLlxuICAgICAgICBsZXQgZGVmYXVsdEFyZ3MgPSAoY2FwRXhlY0FyZ3MubGVuZ3RoKSA/IHByb2Nlc3MuZXhlY0FyZ3YgOiBbXVxuXG4gICAgICAgIC8vIElmIGFuIGFyZyBhcHBlYXJzIG11bHRpcGxlIHRpbWVzIHRoZSBsYXN0IG9jY3VycmVuY2UgaXMgdXNlZFxuICAgICAgICBsZXQgZXhlY0FyZ3YgPSBbIC4uLmRlZmF1bHRBcmdzLCAuLi5kZWJ1Z0FyZ3MsIC4uLmNhcEV4ZWNBcmdzIF1cblxuICAgICAgICAvLyBwcmVmZXIgbGF1bmNoZXIgc2V0dGluZ3MgaW4gY2FwYWJpbGl0aWVzIG92ZXIgZ2VuZXJhbCBsYXVuY2hlclxuICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLnJ1bm5lci5ydW4oe1xuICAgICAgICAgICAgY2lkLFxuICAgICAgICAgICAgY29tbWFuZDogJ3J1bicsXG4gICAgICAgICAgICBjb25maWdGaWxlOiB0aGlzLmNvbmZpZ0ZpbGUsXG4gICAgICAgICAgICBhcmd2OiB0aGlzLmFyZ3YsXG4gICAgICAgICAgICBjYXBzLFxuICAgICAgICAgICAgc3BlY3MsXG4gICAgICAgICAgICBzZXJ2ZXIsXG4gICAgICAgICAgICBleGVjQXJndlxuICAgICAgICB9KVxuICAgICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCA6OnRoaXMuaW50ZXJmYWNlLm9uTWVzc2FnZSlcbiAgICAgICAgd29ya2VyLm9uKCdlcnJvcicsIDo6dGhpcy5pbnRlcmZhY2Uub25NZXNzYWdlKVxuICAgICAgICB3b3JrZXIub24oJ2V4aXQnLCA6OnRoaXMuZW5kSGFuZGxlcilcblxuICAgICAgICB0aGlzLmludGVyZmFjZS5lbWl0KCdqb2I6c3RhcnQnLCB7IGNpZCwgY2Fwcywgc3BlY3MgfSlcbiAgICAgICAgdGhpcy5ydW5uZXJTdGFydGVkKytcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZXMgYSBydW5uZXIgaWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNpZCBjYXBhYmlsaXR5IGlkICh1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBjYXBhYmlsaXR5KVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIHJ1bm5lciBpZCAoY29tYmluYXRpb24gb2YgY2lkIGFuZCB0ZXN0IGlkIGUuZy4gMGEsIDBiLCAxYSwgMWIgLi4uKVxuICAgICAqL1xuICAgIGdldFJ1bm5lcklkIChjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJpZFtjaWRdKSB7XG4gICAgICAgICAgICB0aGlzLnJpZFtjaWRdID0gMFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtjaWR9LSR7dGhpcy5yaWRbY2lkXSsrfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0ZXN0IHJ1bm5lciBwcm9jZXNzIG9uY2UgYWxsIGNoaWxkIHByb2Nlc3NlcyBoYXZlIGV4aXRlZFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2lkICAgICAgIENhcGFiaWxpdGllcyBJRFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZXhpdENvZGUgIGV4aXQgY29kZSBvZiBjaGlsZCBwcm9jZXNzXG4gICAgICovXG4gICAgZW5kSGFuZGxlciAoeyBjaWQsIGV4aXRDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgcGFzc2VkID0gZXhpdENvZGUgPT09IDBcbiAgICAgICAgdGhpcy5leGl0Q29kZSA9IHRoaXMuZXhpdENvZGUgfHwgZXhpdENvZGVcbiAgICAgICAgdGhpcy5ydW5uZXJGYWlsZWQgKz0gIXBhc3NlZCA/IDEgOiAwXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLmVtaXQoJ2pvYjplbmQnLCB7IGNpZCwgcGFzc2VkIH0pXG5cbiAgICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIG5vdyB0aGlzIHByb2Nlc3MgaGFzIGVuZGVkXG4gICAgICAgIGlmICghdGhpcy5pc011bHRpcmVtb3RlKSB7XG4gICAgICAgICAgICAvLyBnZXQgY2lkIChjYXBhYmlsaXR5IGlkKSBmcm9tIHJpZCAocnVubmVyIGlkKVxuICAgICAgICAgICAgY2lkID0gcGFyc2VJbnQoY2lkLCAxMClcblxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVtjaWRdLmF2YWlsYWJsZUluc3RhbmNlcysrXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlW2NpZF0ucnVubmluZ0luc3RhbmNlcy0tXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aXJlbW90ZSAmJiAhdGhpcy5ydW5TcGVjcygpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyZmFjZS5yZXNldCgpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc29sdmUodGhpcy5leGl0Q29kZSksIDEwMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmluaXNoIHdpdGggZXhpdCBjb2RlIDFcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLnVwZGF0ZVZpZXcoKVxuICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UucmVzZXQoKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc29sdmUoMSksIDEwMClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgYWxsIHN0YXJ0ZWQgc2VsZW5pdW0gc2Vzc2lvbnMgZ2V0IGNsb3NlZCBwcm9wZXJseSBhbmQgcHJldmVudFxuICAgICAqIGhhdmluZyBkZWFkIGRyaXZlciBwcm9jZXNzZXMuIFRvIGRvIHNvIGxldCB0aGUgcnVubmVyIGVuZCBpdHMgU2VsZW5pdW1cbiAgICAgKiBzZXNzaW9uIGZpcnN0IGJlZm9yZSBraWxsaW5nXG4gICAgICovXG4gICAgZXhpdEhhbmRsZXIgKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNUcmlnZ2VyZWRFeGl0Um91dGluZSA9IHRydWVcbiAgICAgICAgdGhpcy5pbnRlcmZhY2Uuc2lnaW50VHJpZ2dlcigpXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5lci5zaHV0ZG93bigpLnRoZW4oY2FsbGJhY2spXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXVuY2hlclxuIl19